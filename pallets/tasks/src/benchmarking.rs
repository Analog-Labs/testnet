use crate::{
	BatchIdCounter, Call, Config, Pallet, ShardRegistered, TaskIdCounter, TaskOutput, TaskShard,
};
use frame_benchmarking::benchmarks;
use frame_support::pallet_prelude::Get;
use frame_support::traits::OnInitialize;
use frame_system::RawOrigin;
use pallet_members::MemberPublicKey;
use pallet_networks::NetworkGatewayAddress;
use pallet_shards::{ShardCommitment, ShardState};
use polkadot_sdk::{frame_benchmarking, frame_support, frame_system, sp_core, sp_runtime, sp_std};
use sp_runtime::{BoundedVec, Vec};
use sp_std::vec;
use time_primitives::{
	AccountId, Commitment, GmpEvents, NetworkId, PublicKey, ShardStatus, ShardsInterface, Task,
	TaskId, TaskResult, TasksInterface, TssPublicKey, TssSignature,
};

const ETHEREUM: NetworkId = 0;
// Generated by running tests::bench_helper::print_valid_result
const PUBKEY: TssPublicKey = [
	2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219,
	45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152,
];
const SIGNATURE: TssSignature = [
	119, 119, 90, 235, 7, 120, 43, 92, 165, 239, 64, 155, 193, 120, 121, 158, 221, 101, 67, 71, 77,
	30, 153, 33, 133, 21, 151, 152, 72, 54, 125, 208, 207, 130, 157, 92, 45, 249, 30, 88, 128, 186,
	115, 60, 151, 220, 75, 88, 253, 91, 155, 144, 186, 107, 101, 60, 63, 169, 178, 192, 80, 234,
	63, 100,
];

fn create_shard<
	T: Config + pallet_shards::Config + pallet_networks::Config + pallet_members::Config,
>(
	network: NetworkId,
) {
	NetworkGatewayAddress::<T>::insert(network, [0; 32]);
	let shard_id = <T as Config>::Shards::create_shard(
		network,
		[[0u8; 32].into(), [1u8; 32].into(), [2u8; 32].into()].to_vec(),
		1,
	);
	for m in [[0u8; 32], [1u8; 32], [2u8; 32]] {
		let pk = PublicKey::Sr25519(sp_core::sr25519::Public::from_raw(m));
		let acc: AccountId = m.into();
		MemberPublicKey::<T>::insert(acc, pk);
	}
	ShardCommitment::<T>::insert(shard_id, Commitment(BoundedVec::truncate_from(vec![PUBKEY])));
	ShardRegistered::<T>::insert(PUBKEY, ());
	Pallet::<T>::shard_online(shard_id, network);
	ShardState::<T>::insert(shard_id, ShardStatus::Online);
}

fn create_task<T: Config>(network: NetworkId) -> TaskId {
	Pallet::<T>::create_task(network, Task::ReadGatewayEvents { blocks: 0..10 })
}

benchmarks! {
	where_clause {  where T: pallet_shards::Config + pallet_networks::Config + pallet_members::Config }

	submit_task_result {
		create_shard::<T>(ETHEREUM);
		let task_id = create_task::<T>(ETHEREUM);
		Pallet::<T>::on_initialize(frame_system::Pallet::<T>::block_number());
		assert!(TaskShard::<T>::get(task_id).is_some());
	}: _(
		RawOrigin::Signed([0u8; 32].into()),
		task_id,
		TaskResult::ReadGatewayEvents { events: GmpEvents(BoundedVec::truncate_from(vec![])), signature: SIGNATURE }
	) verify {
		assert_eq!(TaskOutput::<T>::get(task_id), Some(Ok(())));
		assert!(TaskShard::<T>::get(task_id).is_none());
	}

	schedule_tasks {
		let b in 1..<T as Config>::MaxTasksPerBlock::get();
		// reset storage from previous runs
		TaskIdCounter::<T>::take();
		for i in 0..b {
			let network: NetworkId = i.try_into().unwrap_or_default();
			create_shard::<T>(network);
			TaskShard::<T>::take(create_task::<T>(network));
		}
		assert_eq!(TaskIdCounter::<T>::get(), b as u64);
	}: {
		Pallet::<T>::schedule_tasks();
	} verify {
		let mut unassigned = Vec::<u64>::new();
		for i in 0..b {
			let task_id: u64 = i.into();
			if TaskShard::<T>::get(task_id).is_none() {
				unassigned.push(task_id);
			}
		}
		assert_eq!(Vec::<u64>::new(), unassigned);
	}

	prepare_batches {
		let b in 1..<T as Config>::MaxBatchesPerBlock::get();
		// reset storage from previous runs
		BatchIdCounter::<T>::take();
		for i in 0..b {
			let network: NetworkId = i.try_into().unwrap_or_default();
			create_shard::<T>(network);
			create_task::<T>(network);
		}
		assert_eq!(BatchIdCounter::<T>::get(), 0u64);
	}: {
		Pallet::<T>::prepare_batches();
	} verify {
		assert_eq!(BatchIdCounter::<T>::get(), b as u64);
	}

	impl_benchmark_test_suite!(Pallet, crate::mock::new_test_ext(), crate::mock::Test);
}
